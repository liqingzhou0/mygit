atof()函数

函数声明: double atof(const char *str );  
         
功 能： 把字符串转换成浮点数

str：要转换的字符串。

函数返回：返回把字符串str开始部分的数字（和符号）字符转换为 double类型的值，跳过开始的空白字符，遇到第一个非数字字符时结束转换，如果未发现数字字符则返回0；


实现：

//要添加<ctype.h>、<string.h>头文件

// my_atof()函数实现的核心是围绕是否有小数点展开的 即e或E之前的实数


double my_atof(const char * str)
{
	int num=0;                                             //用于记录数字字符的个数。
	int flag=0;                                            //标记小数点的。flag==0时是没小数点的。
	int s=1;                                               //符号位s . 第一个为'-'时，符号为负,s=-1.
	int sE=1;                                              //指数后第一个符号sE 。当E或e后面第一个为'-'时，sE=-1.
	unsigned y=0;                                          //E或e后面的整数值.(即y次方)
	double item=10.0;                                      //小数点后面sum的项;
	double sum=0.0;                                        //浮点数值.
	char ch[]="0123456789-+.";                             //第一个非空白字符:浮点数字符的组成。

	while(*str != '\0')                                    //判断字符串是否为空字符串 不用if 而用while只要是为了方便用break
	{
		while(isspace(*str))                               //跳过空白字符。isspace()函数的声明在<ctype.h>头文件里
		{
			str++;
		}
		if(strchr(ch,*str)==NULL)                           //第一个非空白字符不是浮点数字符，则退出循环。strchr()函数的声明在 <string.h>头文件里
			break;

//判断第一个字符是否为小数点

		if(*str == '-' || *str == '+' || *str == '.')        //第一个字符判断是否为符号或小数点
		{
			if(*str == '-' || *str == '+')                   //第一个字符是否为符号           
			{
				if(*str == '-')                             //符号位为负   
			        s = -1;

				str++;

				if(*str == '.')                             //判断符号后第一个字符是否为小数点
				{
				   flag=1;                                  //表示有小数点了。
				   str++;
				}
			}
			
			else                                            //第一个字符为小数点 相当于if(*str == '.')
			{
				flag=1;                                     //表示有小数点了。	
			    str++;
			}
		}
		
//围绕小数点展开

		if(flag==0)                                          //没有小数点  
		{
			while(*str >= '0' && *str <= '9')                //或者用: char ch[]="0123456789"; while(strchr(ch,*str)!=NULL)
			{			 
			       sum = sum * 10 + (*str-'0') ;             //整数部分  *str-'0'的值为0到9之间。例如: '9'-'0' == 57-48 == 9
				   num++;                                    //记录数字字符个数。
			       str++;
			}

			if(*str == 'E' || *str == 'e' || *str == '.')    //整数部分后面跟小数点、E或e
			{
				if(*str == '.')                              //小数点后面的小数部分
				{
					str++;

					while(*str >= '0' && *str <= '9')        //或者用: char ch[]="0123456789"; while(strchr(ch,*str)!=NULL)
					{			 
				         sum += (*str-'0') / item ;	         //小数部分  item初始值为10.0.  
				         item *= 10.0;
				         num++;                              //记录数字字符个数。
			             str++;
					}
				}
			}

			else                                              //整数部分后面不跟小数点、E或e  退出循环
			      break;
		}

		else                                                 //有小数点。 相当于if(flag != 0)
		{
			while(*str >= '0' && *str <= '9')                //或者用: char ch[]="0123456789"; while(strchr(ch,*str)!=NULL)
			{			 			       
				sum += (*str-'0') / item ;	                 //小数部分  item初始值为10.0.  
				item *= 10.0 ;
				num++;                                       //记录数字字符个数。
			    str++;
			}
		}

//上面为E或e之前的实数部分，而E或e之后是一样的。

        if(*str == 'E' || *str == 'e')                       //小数部分后跟E或e   
		{
			if(num == 0)                                     //如果E或e之前没有数字字符 即E的左边没数字 则退出循环 返回值为0
				break;

			str++;

			if(*str == '-' || *str == '+' )                  //E或e后的第一个字符是否为符号
			{
				if(*str == '-')
					sE = -1;                                 //指数是负数
				str++;
			}

			while(*str >= '0' && *str <= '9')        
			{			 
			       y = y * 10 + (*str-'0') ;                 //计算指数部分的整数值
			       str++;
			}

			if(*str < '0' || *str > '9' )                    //必成立的，指数部分的数字字符完了就退出循环  不要if条件直接break也可以
			    break;			
		}

		else                                                 //小数部分后不跟E或e 则退出循环
			break;		
	}
	
	if(y > 0)                                                //指数部分有非0的正整数值。  y==0 时，10的0次方等于1 故不作判断了。
	{
	   if(sE > 0)                                            //指数为正整数：sum*=10   (相当于sE==1)
		{
			while(y > 0)
			{
				sum *= 10.0 ;
				y--;
			}
		}

	   else                                                 //指数为负整数：sum/=10  (相当于sE==-1)
		{
			while(y > 0)
			{
				sum /= 10.0 ;
				y--;
			}
		}
	}

	return sum*s;                                            //单一出口
}










